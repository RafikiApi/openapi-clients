/*
Resources

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package rafikigen

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// PayoutAPIService PayoutAPI service
type PayoutAPIService service

type ApiPayoutsGetRequest struct {
	ctx context.Context
	ApiService *PayoutAPIService
	createdAtFrom *string
	createdAtTo *string
	pagingLimit *int32
	pagingAfter *string
}

// Filters for payouts created from the specified datetime. The expected format can be either a standard date (YYYY-MM-DD) that defaults to 00:00:00 UTC or a valid RFC3339 string, including time and/or offset information.
func (r ApiPayoutsGetRequest) CreatedAtFrom(createdAtFrom string) ApiPayoutsGetRequest {
	r.createdAtFrom = &createdAtFrom
	return r
}

// Filters for payouts created before the specified datetime. The expected format can be either a standard date (YYYY-MM-DD) that defaults to 23:59:59 UTC or a valid RFC3339 string, including time and/or offset information.
func (r ApiPayoutsGetRequest) CreatedAtTo(createdAtTo string) ApiPayoutsGetRequest {
	r.createdAtTo = &createdAtTo
	return r
}

// The count of items returned as part of the pagination cursor iteration, minimum value is 1 and maximum 50
func (r ApiPayoutsGetRequest) PagingLimit(pagingLimit int32) ApiPayoutsGetRequest {
	r.pagingLimit = &pagingLimit
	return r
}

// The base64 URL encoded cursor used to access the next set of paginated results
func (r ApiPayoutsGetRequest) PagingAfter(pagingAfter string) ApiPayoutsGetRequest {
	r.pagingAfter = &pagingAfter
	return r
}

func (r ApiPayoutsGetRequest) Execute() (*PayoutsGet200Response, *http.Response, error) {
	return r.ApiService.PayoutsGetExecute(r)
}

/*
PayoutsGet List

Using this endpoint, you can list all your historical payouts with an optional dates filter. Considering that the returned data may contain thousands of records, the results will be paginated with a cursor [(see pagination docs)](pagination), allowing you to scroll through the data using multiple requests as necessary.






 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPayoutsGetRequest
*/
func (a *PayoutAPIService) PayoutsGet(ctx context.Context) ApiPayoutsGetRequest {
	return ApiPayoutsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PayoutsGet200Response
func (a *PayoutAPIService) PayoutsGetExecute(r ApiPayoutsGetRequest) (*PayoutsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PayoutsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PayoutAPIService.PayoutsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payouts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.createdAtFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at_from", r.createdAtFrom, "")
	}
	if r.createdAtTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at_to", r.createdAtTo, "")
	}
	if r.pagingLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging_limit", r.pagingLimit, "")
	}
	if r.pagingAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paging_after", r.pagingAfter, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v OpenapiResponseBodyValidationFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v OpenapiResponseBodyInternalServerError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPayoutsIdGetRequest struct {
	ctx context.Context
	ApiService *PayoutAPIService
	id string
}

func (r ApiPayoutsIdGetRequest) Execute() (*PayoutsIdGet200Response, *http.Response, error) {
	return r.ApiService.PayoutsIdGetExecute(r)
}

/*
PayoutsIdGet Get

This endpoint enables the retrieval of a previously accepted payout using its unique ID (`pyt-xxx`). Its primary purpose is to periodically check for changes in the payout status. Currently, we do not provide webhooks, so this method serves as the only available option in such cases.

To learn more about the lifecycle of payouts, please refer to the dedicated section under the [Send Money](post_payouts) endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The Payout ID (pyt-xxx)
 @return ApiPayoutsIdGetRequest
*/
func (a *PayoutAPIService) PayoutsIdGet(ctx context.Context, id string) ApiPayoutsIdGetRequest {
	return ApiPayoutsIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PayoutsIdGet200Response
func (a *PayoutAPIService) PayoutsIdGetExecute(r ApiPayoutsIdGetRequest) (*PayoutsIdGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PayoutsIdGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PayoutAPIService.PayoutsIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payouts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v OpenapiResponseBodyNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v OpenapiResponseBodyInternalServerError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPayoutsPostRequest struct {
	ctx context.Context
	ApiService *PayoutAPIService
	xIdempotencyKey *string
	openapiPayoutCreateRequest *OpenapiPayoutCreateRequest
}

// üö®Ô∏è Prevent duplicate payouts! See: [x-idempotency-key security scheme](idempotency)
func (r ApiPayoutsPostRequest) XIdempotencyKey(xIdempotencyKey string) ApiPayoutsPostRequest {
	r.xIdempotencyKey = &xIdempotencyKey
	return r
}

// The payout
func (r ApiPayoutsPostRequest) OpenapiPayoutCreateRequest(openapiPayoutCreateRequest OpenapiPayoutCreateRequest) ApiPayoutsPostRequest {
	r.openapiPayoutCreateRequest = &openapiPayoutCreateRequest
	return r
}

func (r ApiPayoutsPostRequest) Execute() (*PayoutsPost202Response, *http.Response, error) {
	return r.ApiService.PayoutsPostExecute(r)
}

/*
PayoutsPost Create

The payout resource finds its application in various scenarios where funds need to be disbursed electronically; For example, but not limited to, money remittance services or businesses that need to disburse salaries to their employees.

Regardless of your specific use case, this endpoint has you covered, offering a versatile API to facilitate money disbursement from your [local wallets](get_wallets) to designated recipients (a.k.a [payment accounts](post_payment-accounts)).

> ‚ÑπÔ∏è Lifecycle
>
> If the request you submit meets our minimum validation standards for processing the payout, our server will accept the request. It will defer the execution to a background asynchronous process, and in response, send you an HTTP 202 status code, along with the payout unique identifier.
> <br>
> Upon acceptance, the payout is marked as pending. Your client program will need to poll at intervals to [query the payout state](get_payouts-id) and determine whether it has succeeded or not.
> <br>
> <details>
>  <summary>Payout States</summary>
> <br>
>  <table>
>    <thead>
>        <tr>
>            <th>State</th>
>            <th>Description</th>
>        </tr>
>    </thead>
>    <tbody>
>        <tr>
>            <th>‚è≥<br>PENDING</th>
>            <th>Your payout has been accepted, and it is currently awaiting processing.</th>
>        </tr>
>        <tr>
>           <th>üéâ<br>SENT</th>
>           <th>The payout has been successfully processed, and the intended recipient should have received the funds.</th>
>        </tr>
>        <tr>
>           <th>üîô<br>REVERSED</th>
>           <th>Upon reaching the "SENT" state, you can request a manual reversal (for instance, if funds were sent to the wrong recipient) by contacting our support team. Please be aware that there is no programmatic API available for this process yet. This state indicates a successful reversal.</th>
>        </tr>
>        <tr>
>           <th>üôÖ<br>CANCELLED</th>
>           <th>If the payout has not yet reached the intended recipient, you have the option to request manual cancellation by reaching out to our support team (please note that there is no programmatic API for this yet). This state signifies that the payout has been successfully canceled.</th>
>        </tr>
>        <tr>
>           <th>üíî<br>FAILED</th>
>           <th>
>               The funds did not reach the intended recipient due to a failure. If the "context" property does not provide specific information about the reason for the failure, please contact our customer support for assistance.
>           </th>
>        </tr>
>    </tbody>
>  </table>
>  </details>

> ‚ö†Ô∏è Compliance requirements
> 
> Depending on the country and/or bank you plan to disburse money to, there are specific compliance and regulatory requirements that must be adhered to. For example, some countries might necessitate more comprehensive sender details or impose limits on minimum/maximum payout amounts.
> <br>
> We understand that navigating these varying rules for different countries can be complex, considering the multitude of combinations possible. To simplify this process for you, the table below outlines the specific requirements for each country we offer payout support, streamlining the compliance process.
> <br>
> <details>
<summary>Requirements</summary>
<table>
    <thead>
        <tr>
            <th>Field</th>
            <th>KE üá∞üá™</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>amount.value</td>
            <td>
                <table>
                    <thead>
                         <tr>
                            <th>Min</th>
                            <th>Max</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>140 KES</td>
                            <td>500,000 KES</td> <!-- Kenya -->
                        </tr>
                    </tbody>
                </table>
            </td> <!-- Kenya -->
        </tr>
        <tr>
            <td>sender.type</td>
            <td>Required</td> <!-- Kenya -->
        </tr>
        <tr>
            <td>sender.name</td>
            <td>Required</td> <!-- Kenya -->
        </tr>
        <tr>
            <td>sender.address.line1</td>
            <td>Required</td> <!-- Kenya -->
        </tr>
        <tr>
            <td>sender.address.line2</td>
            <td>-</td> <!-- Kenya -->
        </tr>
        <tr>
            <td>sender.address.line3</td>
            <td>-</td> <!-- Kenya -->
        </tr>
        <tr>
            <td>sender.address.city</td>
            <td>Required</td> <!-- Kenya -->
        </tr>
        <tr>
            <td>sender.address.postal_code</td>
            <td>Required</td> <!-- Kenya -->
        </tr>
        <tr>
            <td>sender.address.country</td>
            <td>Required</td> <!-- Kenya -->
        </tr>
        <tr>
            <td>sender.individual.dob</td>
            <td>Required</td> <!-- Kenya -->
        </tr>
        <tr>
            <td>sender.individual.dob</td>
            <td>Required with INDIVIDUAL sender's type</td> <!-- Kenya -->
        </tr>
        <tr>
            <td>sender.individual.identity_document.type</td>
            <td>-</td> <!-- Kenya -->
        </tr>
        <tr>
            <td>sender.individual.identity_document.country</td>
            <td>-</td> <!-- Kenya -->
        </tr>
        <tr>
            <td>sender.individual.identity_document.number</td>
            <td>-</td> <!-- Kenya -->
        </tr>
        <tr>
            <td>sender.individual.identity_document.issued_on</td>
            <td>-</td> <!-- Kenya -->
        </tr>
        <tr>
            <td>sender.individual.identity_document.expires_on</td>
            <td>-</td> <!-- Kenya -->
        </tr>
    </tbody>
</table>
</details>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPayoutsPostRequest
*/
func (a *PayoutAPIService) PayoutsPost(ctx context.Context) ApiPayoutsPostRequest {
	return ApiPayoutsPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PayoutsPost202Response
func (a *PayoutAPIService) PayoutsPostExecute(r ApiPayoutsPostRequest) (*PayoutsPost202Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PayoutsPost202Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PayoutAPIService.PayoutsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payouts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.xIdempotencyKey == nil {
		return localVarReturnValue, nil, reportError("xIdempotencyKey is required and must be specified")
	}
	if r.openapiPayoutCreateRequest == nil {
		return localVarReturnValue, nil, reportError("openapiPayoutCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Idempotency-Key", r.xIdempotencyKey, "")
	// body params
	localVarPostBody = r.openapiPayoutCreateRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v OpenapiResponseBodyWalletInsufficientBalance
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v OpenapiResponseBodyIdempotencyConflict
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v OpenapiResponseBodyValidationFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v OpenapiResponseBodyInternalServerError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
