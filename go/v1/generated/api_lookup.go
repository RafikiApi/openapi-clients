/*
Resources

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package rafikigen

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// LookupAPIService LookupAPI service
type LookupAPIService service

type ApiLookupsAccountNumberGetRequest struct {
	ctx context.Context
	ApiService *LookupAPIService
	paymentAccountType *string
	accountNumber string
	bankId *string
	operator *string
}

// The payment account type to lookup for
func (r ApiLookupsAccountNumberGetRequest) PaymentAccountType(paymentAccountType string) ApiLookupsAccountNumberGetRequest {
	r.paymentAccountType = &paymentAccountType
	return r
}

// If payment_account_type is BANK_ACCOUNT, this will be a mandatory field representing the bank id (bnk-xxx) used to identify which bank the account number belongs to
func (r ApiLookupsAccountNumberGetRequest) BankId(bankId string) ApiLookupsAccountNumberGetRequest {
	r.bankId = &bankId
	return r
}

// If payment_account_type is MOBILE_MONEY, this will be a mandatory field representing the mobile money operator
func (r ApiLookupsAccountNumberGetRequest) Operator(operator string) ApiLookupsAccountNumberGetRequest {
	r.operator = &operator
	return r
}

func (r ApiLookupsAccountNumberGetRequest) Execute() (*LookupsAccountNumberGet200Response, *http.Response, error) {
	return r.ApiService.LookupsAccountNumberGetExecute(r)
}

/*
LookupsAccountNumberGet Get

The lookup resource facilitates the retrieval of metadata associated with mobile money or bank accounts. For instance, prior to creating payment accounts, you can utilize this endpoint to validate whether an account number corresponds to a specific business or individual.

This functionality proves especially valuable in ensuring that only validated payment accounts are utilized; for example, when integrated with other processes, such as payouts, it helps mitigate the risk of costly reversals or refunds resulting from funds being sent to an incorrect recipient.

### Account not found

While we strive to ensure that our lookup sources are always up to date with the most recent data, we must consider instances when we cannot retrieve metadata for a requested payment account.

In such cases, our API will respond with the error code [LOOKUP_ACCOUNT_NOT_FOUND](error-codes#lookup_account_not_found-http-404), providing a way to programmatically determine whether the account lookup was unsuccessful.

For some cases like Kenya mobile money lookups, try again in 5 minutes after getting the `LOOKUP_ACCOUNT_NOT_FOUND` error. If we respond with the same error again, it is likely that the account is not registered with the operator.

### Supported countries/account types

| Country       | Mobile Money | Bank Account |
|:--------------|:------------:|:------------:|
| 🇳🇬 Nigeria  |     ❌       |      ✅      |
| 🇺🇬 Uganda   |     ✅       |      ✅      |
| 🇬🇭 Ghana    |     ✅       |      ✅      |
| 🇰🇪 Kenya    |     ✅       |      ✅      |


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountNumber The account number, that is either the mobile money number or bank account number
 @return ApiLookupsAccountNumberGetRequest
*/
func (a *LookupAPIService) LookupsAccountNumberGet(ctx context.Context, accountNumber string) ApiLookupsAccountNumberGetRequest {
	return ApiLookupsAccountNumberGetRequest{
		ApiService: a,
		ctx: ctx,
		accountNumber: accountNumber,
	}
}

// Execute executes the request
//  @return LookupsAccountNumberGet200Response
func (a *LookupAPIService) LookupsAccountNumberGetExecute(r ApiLookupsAccountNumberGetRequest) (*LookupsAccountNumberGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LookupsAccountNumberGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LookupAPIService.LookupsAccountNumberGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/lookups/{accountNumber}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountNumber"+"}", url.PathEscape(parameterValueToString(r.accountNumber, "accountNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.paymentAccountType == nil {
		return localVarReturnValue, nil, reportError("paymentAccountType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "payment_account_type", r.paymentAccountType, "")
	if r.bankId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bank_id", r.bankId, "")
	}
	if r.operator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "operator", r.operator, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Bearer"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v OpenapiResponseBodyLookupAccountNotFound
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v OpenapiResponseBodyValidationFailed
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v OpenapiResponseBodyInternalServerError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
