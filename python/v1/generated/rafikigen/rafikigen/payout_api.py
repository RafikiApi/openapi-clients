# coding: utf-8

"""
    Resources

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError

from typing_extensions import Annotated
from pydantic import Field, StrictInt, StrictStr

from typing import Optional

from rafikigen.models.openapi_payout_create_request import OpenapiPayoutCreateRequest
from rafikigen.models.payouts_get200_response import PayoutsGet200Response
from rafikigen.models.payouts_id_get200_response import PayoutsIdGet200Response
from rafikigen.models.payouts_post202_response import PayoutsPost202Response

from rafikigen.api_client import ApiClient
from rafikigen.api_response import ApiResponse
from rafikigen.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class PayoutApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def payouts_get(self, created_at_from : Annotated[Optional[StrictStr], Field(description="Filters for payouts created from the specified datetime. The expected format can be either a standard date (YYYY-MM-DD) that defaults to 00:00:00 UTC or a valid RFC3339 string, including time and/or offset information.")] = None, created_at_to : Annotated[Optional[StrictStr], Field(description="Filters for payouts created before the specified datetime. The expected format can be either a standard date (YYYY-MM-DD) that defaults to 23:59:59 UTC or a valid RFC3339 string, including time and/or offset information.")] = None, paging_limit : Annotated[Optional[StrictInt], Field(description="The count of items returned as part of the pagination cursor iteration, minimum value is 1 and maximum 50")] = None, paging_after : Annotated[Optional[StrictStr], Field(description="The base64 URL encoded cursor used to access the next set of paginated results")] = None, **kwargs) -> PayoutsGet200Response:  # noqa: E501
        """List  # noqa: E501

        Using this endpoint, you can list all your historical payouts with an optional dates filter. Considering that the returned data may contain thousands of records, the results will be paginated with a cursor [(see pagination docs)](pagination), allowing you to scroll through the data using multiple requests as necessary.       # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.payouts_get(created_at_from, created_at_to, paging_limit, paging_after, async_req=True)
        >>> result = thread.get()

        :param created_at_from: Filters for payouts created from the specified datetime. The expected format can be either a standard date (YYYY-MM-DD) that defaults to 00:00:00 UTC or a valid RFC3339 string, including time and/or offset information.
        :type created_at_from: str
        :param created_at_to: Filters for payouts created before the specified datetime. The expected format can be either a standard date (YYYY-MM-DD) that defaults to 23:59:59 UTC or a valid RFC3339 string, including time and/or offset information.
        :type created_at_to: str
        :param paging_limit: The count of items returned as part of the pagination cursor iteration, minimum value is 1 and maximum 50
        :type paging_limit: int
        :param paging_after: The base64 URL encoded cursor used to access the next set of paginated results
        :type paging_after: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PayoutsGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the payouts_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.payouts_get_with_http_info(created_at_from, created_at_to, paging_limit, paging_after, **kwargs)  # noqa: E501

    @validate_arguments
    def payouts_get_with_http_info(self, created_at_from : Annotated[Optional[StrictStr], Field(description="Filters for payouts created from the specified datetime. The expected format can be either a standard date (YYYY-MM-DD) that defaults to 00:00:00 UTC or a valid RFC3339 string, including time and/or offset information.")] = None, created_at_to : Annotated[Optional[StrictStr], Field(description="Filters for payouts created before the specified datetime. The expected format can be either a standard date (YYYY-MM-DD) that defaults to 23:59:59 UTC or a valid RFC3339 string, including time and/or offset information.")] = None, paging_limit : Annotated[Optional[StrictInt], Field(description="The count of items returned as part of the pagination cursor iteration, minimum value is 1 and maximum 50")] = None, paging_after : Annotated[Optional[StrictStr], Field(description="The base64 URL encoded cursor used to access the next set of paginated results")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """List  # noqa: E501

        Using this endpoint, you can list all your historical payouts with an optional dates filter. Considering that the returned data may contain thousands of records, the results will be paginated with a cursor [(see pagination docs)](pagination), allowing you to scroll through the data using multiple requests as necessary.       # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.payouts_get_with_http_info(created_at_from, created_at_to, paging_limit, paging_after, async_req=True)
        >>> result = thread.get()

        :param created_at_from: Filters for payouts created from the specified datetime. The expected format can be either a standard date (YYYY-MM-DD) that defaults to 00:00:00 UTC or a valid RFC3339 string, including time and/or offset information.
        :type created_at_from: str
        :param created_at_to: Filters for payouts created before the specified datetime. The expected format can be either a standard date (YYYY-MM-DD) that defaults to 23:59:59 UTC or a valid RFC3339 string, including time and/or offset information.
        :type created_at_to: str
        :param paging_limit: The count of items returned as part of the pagination cursor iteration, minimum value is 1 and maximum 50
        :type paging_limit: int
        :param paging_after: The base64 URL encoded cursor used to access the next set of paginated results
        :type paging_after: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PayoutsGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'created_at_from',
            'created_at_to',
            'paging_limit',
            'paging_after'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method payouts_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('created_at_from') is not None:  # noqa: E501
            _query_params.append(('created_at_from', _params['created_at_from']))

        if _params.get('created_at_to') is not None:  # noqa: E501
            _query_params.append(('created_at_to', _params['created_at_to']))

        if _params.get('paging_limit') is not None:  # noqa: E501
            _query_params.append(('paging_limit', _params['paging_limit']))

        if _params.get('paging_after') is not None:  # noqa: E501
            _query_params.append(('paging_after', _params['paging_after']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {
            '200': "PayoutsGet200Response",
            '422': "OpenapiResponseBodyValidationFailed",
            '500': "OpenapiResponseBodyInternalServerError",
        }

        return self.api_client.call_api(
            '/payouts', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def payouts_id_get(self, id : Annotated[StrictStr, Field(..., description="The Payout ID (pyt-xxx) or the custom_id provided at the time of payout creation")], **kwargs) -> PayoutsIdGet200Response:  # noqa: E501
        """Get  # noqa: E501

        This endpoint enables the retrieval of a previously accepted payout using its unique ID (`pyt-xxx`) or the `custom_id` submitted when creating it. Its primary purpose is to periodically check for changes in the payout status.  To learn more about the lifecycle of payouts, please refer to the dedicated section under the [Send Money](post_payouts) endpoint.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.payouts_id_get(id, async_req=True)
        >>> result = thread.get()

        :param id: The Payout ID (pyt-xxx) or the custom_id provided at the time of payout creation (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PayoutsIdGet200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the payouts_id_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.payouts_id_get_with_http_info(id, **kwargs)  # noqa: E501

    @validate_arguments
    def payouts_id_get_with_http_info(self, id : Annotated[StrictStr, Field(..., description="The Payout ID (pyt-xxx) or the custom_id provided at the time of payout creation")], **kwargs) -> ApiResponse:  # noqa: E501
        """Get  # noqa: E501

        This endpoint enables the retrieval of a previously accepted payout using its unique ID (`pyt-xxx`) or the `custom_id` submitted when creating it. Its primary purpose is to periodically check for changes in the payout status.  To learn more about the lifecycle of payouts, please refer to the dedicated section under the [Send Money](post_payouts) endpoint.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.payouts_id_get_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param id: The Payout ID (pyt-xxx) or the custom_id provided at the time of payout creation (required)
        :type id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PayoutsIdGet200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method payouts_id_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['id']:
            _path_params['id'] = _params['id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {
            '200': "PayoutsIdGet200Response",
            '404': "OpenapiResponseBodyNotFound",
            '500': "OpenapiResponseBodyInternalServerError",
        }

        return self.api_client.call_api(
            '/payouts/{id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def payouts_post(self, x_idempotency_key : Annotated[StrictStr, Field(..., description="ğŸš¨ï¸ Prevent duplicate payouts! See: [x-idempotency-key security scheme](idempotency)")], openapi_payout_create_request : Annotated[OpenapiPayoutCreateRequest, Field(..., description="The payout")], **kwargs) -> PayoutsPost202Response:  # noqa: E501
        """Create  # noqa: E501

        The payout resource finds its application in various scenarios where funds need to be disbursed electronically; For example, but not limited to, money remittance services or businesses that need to disburse salaries to their employees.  Regardless of your specific use case, this endpoint has you covered, offering a versatile API to facilitate money disbursement from your [local wallets](get_wallets) to designated recipients (a.k.a [payment accounts](post_payment-accounts)).  > â„¹ï¸ Lifecycle > > If the request you submit meets our minimum validation standards for processing the payout, our server will accept the request. It will defer the execution to a background asynchronous process, and in response, send you an HTTP 202 status code, along with the payout unique identifier. > <br> > Upon acceptance, the payout is marked as pending. Your client program will need to poll at intervals to [query the payout state](get_payouts-id) and determine whether it has succeeded or not. After the payout is completed, provided [webhook notifications](webhooks) are set up, Rafiki will also dispatch [payout.state-updated](payoutstate-updated) events > <br> > > <details> >  <summary>Payout States</summary> > <br> >  <table> >    <thead> >        <tr> >            <th>State</th> >            <th>Description</th> >        </tr> >    </thead> >    <tbody> >        <tr> >            <th>â³<br>PENDING</th> >            <th>Your payout has been accepted, and it is currently awaiting processing.</th> >        </tr> >        <tr> >           <th>ğŸ‰<br>SENT</th> >           <th>The payout has been successfully processed, and the intended recipient should have received the funds.</th> >        </tr> >        <tr> >           <th>ğŸ”™<br>REVERSED</th> >           <th>Upon reaching the \"SENT\" state, you can request a manual reversal (for instance, if funds were sent to the wrong recipient) by contacting our support team. Please be aware that there is no programmatic API available for this process yet. This state indicates a successful reversal.</th> >        </tr> >        <tr> >           <th>ğŸ™…<br>CANCELLED</th> >           <th>If the payout has not yet reached the intended recipient, you have the option to request manual cancellation by reaching out to our support team (please note that there is no programmatic API for this yet). This state signifies that the payout has been successfully canceled.</th> >        </tr> >        <tr> >           <th>ğŸ’”<br>FAILED</th> >           <th> >               The funds did not reach the intended recipient due to a failure. If the \"context\" property does not provide specific information about the reason for the failure, please contact our customer support for assistance. >           </th> >        </tr> >    </tbody> >  </table> >  </details> > <br> > <details> >  <summary>Payout state context</summary> > <br> > When a payout fails, the \"context\" property of the state object will provide additional information about the reason for the failure. The table below outlines the possible values for this property. > > #### `WALLET_INSUFFICIENT_BALANCE` > > The selected wallet currently doesn't have enough money to process the payout. <br><br> > > #### `PAYMENT_ACCOUNT_INVALID_ACCOUNT_NUMBER` > > The account number provided is invalid. <br><br> > > #### `PAYMENT_ACCOUNT_BALANCE_MAXED_OUT` > > The payment account balance has reached the maximum allowed. <br><br> > > #### `PAYMENT_ACCOUNT_PER_TRANSACTION_LIMIT_REACHED` > > The amount to be sent exceeds the maximum allowed per transaction for this payment account <br><br> > > #### `PAYMENT_ACCOUNT_DAILY_LIMIT_REACHED` > > The payment account has reached the daily limit or would reach it by processing this payout. <br><br> > > #### `PAYMENT_ACCOUNT_MONTHLY_LIMIT_REACHED` > > The payment account has reached the monthly limit or would reach it by processing this payout. <br><br> > > #### `PAYMENT_ACCOUNT_LIMIT_REACHED` > > The payment account has reached a limit but we don't know which one. <br><br> > >  </details>  > âš ï¸ Compliance requirements > > Depending on the country and/or bank you plan to disburse money to, there are specific compliance and regulatory requirements that must be adhered to. For example, some countries might necessitate more comprehensive sender details or impose limits on minimum/maximum payout amounts. > <br> > We understand that navigating these varying rules for different countries can be complex, considering the multitude of combinations possible. To simplify this process, you can detail the requirements for each country listed below. > <br> > > <details> > <summary>ğŸ‡°ğŸ‡ª Kenya</summary> > <table> >     <thead> >         <tr> >             <th>Field</th> >         </tr> >     </thead> >     <tbody> >         <tr> >             <td>amount.value</td> >             <td> >                 <table> >                     <thead> >                          <tr> >                             <th>Min</th> >                             <th>Max</th> >                         </tr> >                     </thead> >                     <tbody> >                         <tr> >                             <td>140 KES</td> >                             <td>500,000 KES</td> >                         </tr> >                     </tbody> >                 </table> >             </td> >         </tr> >         <tr> >             <td>sender.type</td> >             <td>Required</td> <!-- Kenya --> >         </tr> >         <tr> >             <td>sender.name</td> >             <td>Required</td> <!-- Kenya --> >         </tr> >         <tr> >             <td>sender.address.line1</td> >             <td>Required</td> <!-- Kenya --> >         </tr> >         <tr> >             <td>sender.address.line2</td> >             <td>-</td> <!-- Kenya --> >         </tr> >         <tr> >             <td>sender.address.line3</td> >             <td>-</td> <!-- Kenya --> >         </tr> >         <tr> >             <td>sender.address.city</td> >             <td>Required</td> <!-- Kenya --> >         </tr> >         <tr> >             <td>sender.address.postal_code</td> >             <td>Required</td> <!-- Kenya --> >         </tr> >         <tr> >             <td>sender.address.country</td> >             <td>Required</td> <!-- Kenya --> >         </tr> >         <tr> >             <td>sender.individual.dob</td> >             <td>Required (with type INDIVIDUAL)</td> <!-- Kenya --> >         </tr> >         <tr> >             <td>sender.individual.identity_document.country</td> >             <td>-</td> <!-- Kenya --> >         </tr> >         <tr> >             <td>sender.individual.identity_document.number</td> >             <td>-</td> <!-- Kenya --> >         </tr> >         <tr> >             <td>sender.individual.identity_document.issued_on</td> >             <td>-</td> <!-- Kenya --> >         </tr> >         <tr> >             <td>sender.individual.identity_document.expires_on</td> >             <td>-</td> <!-- Kenya --> >         </tr> >     </tbody> > </table> > <br> > </details> >  > <details> > <summary>ğŸ‡³ğŸ‡¬ Nigeria</summary> > <table> >     <thead> >         <tr> >             <th>Field</th> >         </tr> >     </thead> >     <tbody> >         <tr> >             <td>amount.value</td> >             <td> >                 <table> >                     <thead> >                          <tr> >                             <th>Min</th> >                             <th>Max</th> >                         </tr> >                     </thead> >                     <tbody> >                         <tr> >                             <td>100 NGN</td> >                             <td> - </td> <!-- TODO --> >                         </tr> >                     </tbody> >                 </table> >             </td> <!-- Nigeria --> >         </tr> >         <tr> >             <td>sender.type</td> >             <td>Required</td> <!-- Nigeria --> >         </tr> >         <tr> >             <td>sender.name</td> >             <td>Required</td> <!-- Nigeria --> >         </tr> >         <tr> >             <td>sender.address.line1</td> >             <td>Required</td> <!-- Nigeria --> >         </tr> >         <tr> >             <td>sender.address.line2</td> >             <td>-</td> <!-- Nigeria --> >         </tr> >         <tr> >             <td>sender.address.line3</td> >             <td>-</td> <!-- Nigeria --> >         </tr> >         <tr> >             <td>sender.address.city</td> >             <td>Required</td> <!-- Nigeria --> >         </tr> >         <tr> >             <td>sender.address.postal_code</td> >             <td>Required</td> <!-- Nigeria --> >         </tr> >         <tr> >             <td>sender.address.country</td> >             <td>Required</td> <!-- Nigeria --> >         </tr> >         <tr> >             <td>sender.individual.dob</td> >             <td>Required (with type INDIVIDUAL)</td> <!-- Nigeria --> >         </tr> >         <tr> >             <td>sender.individual.identity_document.country</td> >             <td>Required (with type INDIVIDUAL)</td> <!-- Nigeria --> >         </tr> >         <tr> >             <td>sender.individual.identity_document.number</td> >             <td>Required (with type INDIVIDUAL)</td> <!-- Nigeria --> >         </tr> >         <tr> >             <td>sender.individual.identity_document.issued_on</td> >             <td>-</td> <!-- Nigeria --> >         </tr> >         <tr> >             <td>sender.individual.identity_document.expires_on</td> >             <td>Required (with type INDIVIDUAL)</td> <!-- Nigeria --> >         </tr> >     </tbody> > </table> > <br> > </details> >  > <details> > <summary>ğŸ‡¹ğŸ‡¿ Tanzania</summary> > <table> >     <thead> >         <tr> >             <th>Field</th> >         </tr> >     </thead> >     <tbody> >         <tr> >             <td>amount.value</td> >             <td> >                 <table> >                     <thead> >                          <tr> >                             <th>Min</th> >                             <th>Max</th> >                         </tr> >                     </thead> >                     <tbody> >                         <tr> >                             <td>2,500 TZS</td> >                             <td>1,000,000 TZS</td> >                         </tr> >                     </tbody> >                 </table> >             </td> <!-- Tanzania --> >         </tr> >         <tr> >             <td>sender.type</td> >             <td>Required</td> <!-- Tanzania --> >         </tr> >         <tr> >             <td>sender.name</td> >             <td>Required</td> <!-- Tanzania --> >         </tr> >         <tr> >             <td>sender.address.line1</td> >             <td>Required</td> <!-- Tanzania --> >         </tr> >         <tr> >             <td>sender.address.line2</td> >             <td>-</td> <!-- Tanzania --> >         </tr> >         <tr> >             <td>sender.address.line3</td> >             <td>-</td> <!-- Tanzania --> >         </tr> >         <tr> >             <td>sender.address.city</td> >             <td>Required</td> <!-- Tanzania --> >         </tr> >         <tr> >             <td>sender.address.postal_code</td> >             <td>Required</td> <!-- Tanzania --> >         </tr> >         <tr> >             <td>sender.address.country</td> >             <td>Required</td> <!-- Tanzania --> >         </tr> >         <tr> >             <td>sender.individual.dob</td> >             <td>Required (with type INDIVIDUAL)</td> <!-- Tanzania --> >         </tr> >         <tr> >             <td>sender.individual.identity_document.country</td> >             <td>Required (with type INDIVIDUAL)</td> <!-- Tanzania --> >         </tr> >         <tr> >             <td>sender.individual.identity_document.number</td> >             <td>Required (with type INDIVIDUAL)</td> <!-- Tanzania --> >         </tr> >         <tr> >             <td>sender.individual.identity_document.issued_on</td> >             <td>-</td> <!-- Tanzania --> >         </tr> >         <tr> >             <td>sender.individual.identity_document.expires_on</td> >             <td>Required (with type INDIVIDUAL)</td> <!-- Tanzania --> >         </tr> >     </tbody> > </table> > <br> > </details> >  > <details> > <summary>ğŸ‡·ğŸ‡¼ Rwanda</summary> > <table> >     <thead> >         <tr> >             <th>Field</th> >         </tr> >     </thead> >     <tbody> >         <tr> >             <td>amount.value</td> >             <td> >                 <table> >                     <thead> >                         <tr> >                             <th>Min</th> >                             <th>Max</th> >                         </tr> >                     </thead> >                     <tbody> >                         <tr> >                             <td>500 RWF</td> >                             <td>-</td> >                         </tr> >                     </tbody> >                 </table> >             </td> <!-- Rwanda --> >         </tr> >         <tr> >             <td>sender.type</td> >             <td>Required</td> <!-- Rwanda --> >         </tr> >         <tr> >             <td>sender.name</td> >             <td>Required</td> <!-- Rwanda --> >         </tr> >         <tr> >             <td>sender.address.line1</td> >             <td>Required</td> <!-- Rwanda --> >         </tr> >         <tr> >             <td>sender.address.line2</td> >             <td>-</td> <!-- Rwanda --> >         </tr> >         <tr> >             <td>sender.address.line3</td> >             <td>-</td> <!-- Rwanda --> >         </tr> >         <tr> >             <td>sender.address.city</td> >             <td>Required</td> <!-- Rwanda --> >         </tr> >         <tr> >             <td>sender.address.postal_code</td> >             <td>Required</td> <!-- Rwanda --> >         </tr> >         <tr> >             <td>sender.address.country</td> >             <td>Required</td> <!-- Rwanda --> >         </tr> >         <tr> >             <td>sender.individual.dob</td> >             <td>Required (with type INDIVIDUAL)</td> <!-- Rwanda --> >         </tr> >         <tr> >             <td>sender.individual.identity_document.country</td> >             <td>Required (with type INDIVIDUAL)</td> <!-- Rwanda --> >         </tr> >         <tr> >             <td>sender.individual.identity_document.number</td> >             <td>Required (with type INDIVIDUAL)</td> <!-- Rwanda --> >         </tr> >         <tr> >             <td>sender.individual.identity_document.issued_on</td> >             <td>-</td> <!-- Rwanda --> >         </tr> >         <tr> >             <td>sender.individual.identity_document.expires_on</td> >             <td>Required (with type INDIVIDUAL)</td> <!-- Rwanda --> >         </tr> >     </tbody> > </table> > <br> > </details>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.payouts_post(x_idempotency_key, openapi_payout_create_request, async_req=True)
        >>> result = thread.get()

        :param x_idempotency_key: ğŸš¨ï¸ Prevent duplicate payouts! See: [x-idempotency-key security scheme](idempotency) (required)
        :type x_idempotency_key: str
        :param openapi_payout_create_request: The payout (required)
        :type openapi_payout_create_request: OpenapiPayoutCreateRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PayoutsPost202Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the payouts_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.payouts_post_with_http_info(x_idempotency_key, openapi_payout_create_request, **kwargs)  # noqa: E501

    @validate_arguments
    def payouts_post_with_http_info(self, x_idempotency_key : Annotated[StrictStr, Field(..., description="ğŸš¨ï¸ Prevent duplicate payouts! See: [x-idempotency-key security scheme](idempotency)")], openapi_payout_create_request : Annotated[OpenapiPayoutCreateRequest, Field(..., description="The payout")], **kwargs) -> ApiResponse:  # noqa: E501
        """Create  # noqa: E501

        The payout resource finds its application in various scenarios where funds need to be disbursed electronically; For example, but not limited to, money remittance services or businesses that need to disburse salaries to their employees.  Regardless of your specific use case, this endpoint has you covered, offering a versatile API to facilitate money disbursement from your [local wallets](get_wallets) to designated recipients (a.k.a [payment accounts](post_payment-accounts)).  > â„¹ï¸ Lifecycle > > If the request you submit meets our minimum validation standards for processing the payout, our server will accept the request. It will defer the execution to a background asynchronous process, and in response, send you an HTTP 202 status code, along with the payout unique identifier. > <br> > Upon acceptance, the payout is marked as pending. Your client program will need to poll at intervals to [query the payout state](get_payouts-id) and determine whether it has succeeded or not. After the payout is completed, provided [webhook notifications](webhooks) are set up, Rafiki will also dispatch [payout.state-updated](payoutstate-updated) events > <br> > > <details> >  <summary>Payout States</summary> > <br> >  <table> >    <thead> >        <tr> >            <th>State</th> >            <th>Description</th> >        </tr> >    </thead> >    <tbody> >        <tr> >            <th>â³<br>PENDING</th> >            <th>Your payout has been accepted, and it is currently awaiting processing.</th> >        </tr> >        <tr> >           <th>ğŸ‰<br>SENT</th> >           <th>The payout has been successfully processed, and the intended recipient should have received the funds.</th> >        </tr> >        <tr> >           <th>ğŸ”™<br>REVERSED</th> >           <th>Upon reaching the \"SENT\" state, you can request a manual reversal (for instance, if funds were sent to the wrong recipient) by contacting our support team. Please be aware that there is no programmatic API available for this process yet. This state indicates a successful reversal.</th> >        </tr> >        <tr> >           <th>ğŸ™…<br>CANCELLED</th> >           <th>If the payout has not yet reached the intended recipient, you have the option to request manual cancellation by reaching out to our support team (please note that there is no programmatic API for this yet). This state signifies that the payout has been successfully canceled.</th> >        </tr> >        <tr> >           <th>ğŸ’”<br>FAILED</th> >           <th> >               The funds did not reach the intended recipient due to a failure. If the \"context\" property does not provide specific information about the reason for the failure, please contact our customer support for assistance. >           </th> >        </tr> >    </tbody> >  </table> >  </details> > <br> > <details> >  <summary>Payout state context</summary> > <br> > When a payout fails, the \"context\" property of the state object will provide additional information about the reason for the failure. The table below outlines the possible values for this property. > > #### `WALLET_INSUFFICIENT_BALANCE` > > The selected wallet currently doesn't have enough money to process the payout. <br><br> > > #### `PAYMENT_ACCOUNT_INVALID_ACCOUNT_NUMBER` > > The account number provided is invalid. <br><br> > > #### `PAYMENT_ACCOUNT_BALANCE_MAXED_OUT` > > The payment account balance has reached the maximum allowed. <br><br> > > #### `PAYMENT_ACCOUNT_PER_TRANSACTION_LIMIT_REACHED` > > The amount to be sent exceeds the maximum allowed per transaction for this payment account <br><br> > > #### `PAYMENT_ACCOUNT_DAILY_LIMIT_REACHED` > > The payment account has reached the daily limit or would reach it by processing this payout. <br><br> > > #### `PAYMENT_ACCOUNT_MONTHLY_LIMIT_REACHED` > > The payment account has reached the monthly limit or would reach it by processing this payout. <br><br> > > #### `PAYMENT_ACCOUNT_LIMIT_REACHED` > > The payment account has reached a limit but we don't know which one. <br><br> > >  </details>  > âš ï¸ Compliance requirements > > Depending on the country and/or bank you plan to disburse money to, there are specific compliance and regulatory requirements that must be adhered to. For example, some countries might necessitate more comprehensive sender details or impose limits on minimum/maximum payout amounts. > <br> > We understand that navigating these varying rules for different countries can be complex, considering the multitude of combinations possible. To simplify this process, you can detail the requirements for each country listed below. > <br> > > <details> > <summary>ğŸ‡°ğŸ‡ª Kenya</summary> > <table> >     <thead> >         <tr> >             <th>Field</th> >         </tr> >     </thead> >     <tbody> >         <tr> >             <td>amount.value</td> >             <td> >                 <table> >                     <thead> >                          <tr> >                             <th>Min</th> >                             <th>Max</th> >                         </tr> >                     </thead> >                     <tbody> >                         <tr> >                             <td>140 KES</td> >                             <td>500,000 KES</td> >                         </tr> >                     </tbody> >                 </table> >             </td> >         </tr> >         <tr> >             <td>sender.type</td> >             <td>Required</td> <!-- Kenya --> >         </tr> >         <tr> >             <td>sender.name</td> >             <td>Required</td> <!-- Kenya --> >         </tr> >         <tr> >             <td>sender.address.line1</td> >             <td>Required</td> <!-- Kenya --> >         </tr> >         <tr> >             <td>sender.address.line2</td> >             <td>-</td> <!-- Kenya --> >         </tr> >         <tr> >             <td>sender.address.line3</td> >             <td>-</td> <!-- Kenya --> >         </tr> >         <tr> >             <td>sender.address.city</td> >             <td>Required</td> <!-- Kenya --> >         </tr> >         <tr> >             <td>sender.address.postal_code</td> >             <td>Required</td> <!-- Kenya --> >         </tr> >         <tr> >             <td>sender.address.country</td> >             <td>Required</td> <!-- Kenya --> >         </tr> >         <tr> >             <td>sender.individual.dob</td> >             <td>Required (with type INDIVIDUAL)</td> <!-- Kenya --> >         </tr> >         <tr> >             <td>sender.individual.identity_document.country</td> >             <td>-</td> <!-- Kenya --> >         </tr> >         <tr> >             <td>sender.individual.identity_document.number</td> >             <td>-</td> <!-- Kenya --> >         </tr> >         <tr> >             <td>sender.individual.identity_document.issued_on</td> >             <td>-</td> <!-- Kenya --> >         </tr> >         <tr> >             <td>sender.individual.identity_document.expires_on</td> >             <td>-</td> <!-- Kenya --> >         </tr> >     </tbody> > </table> > <br> > </details> >  > <details> > <summary>ğŸ‡³ğŸ‡¬ Nigeria</summary> > <table> >     <thead> >         <tr> >             <th>Field</th> >         </tr> >     </thead> >     <tbody> >         <tr> >             <td>amount.value</td> >             <td> >                 <table> >                     <thead> >                          <tr> >                             <th>Min</th> >                             <th>Max</th> >                         </tr> >                     </thead> >                     <tbody> >                         <tr> >                             <td>100 NGN</td> >                             <td> - </td> <!-- TODO --> >                         </tr> >                     </tbody> >                 </table> >             </td> <!-- Nigeria --> >         </tr> >         <tr> >             <td>sender.type</td> >             <td>Required</td> <!-- Nigeria --> >         </tr> >         <tr> >             <td>sender.name</td> >             <td>Required</td> <!-- Nigeria --> >         </tr> >         <tr> >             <td>sender.address.line1</td> >             <td>Required</td> <!-- Nigeria --> >         </tr> >         <tr> >             <td>sender.address.line2</td> >             <td>-</td> <!-- Nigeria --> >         </tr> >         <tr> >             <td>sender.address.line3</td> >             <td>-</td> <!-- Nigeria --> >         </tr> >         <tr> >             <td>sender.address.city</td> >             <td>Required</td> <!-- Nigeria --> >         </tr> >         <tr> >             <td>sender.address.postal_code</td> >             <td>Required</td> <!-- Nigeria --> >         </tr> >         <tr> >             <td>sender.address.country</td> >             <td>Required</td> <!-- Nigeria --> >         </tr> >         <tr> >             <td>sender.individual.dob</td> >             <td>Required (with type INDIVIDUAL)</td> <!-- Nigeria --> >         </tr> >         <tr> >             <td>sender.individual.identity_document.country</td> >             <td>Required (with type INDIVIDUAL)</td> <!-- Nigeria --> >         </tr> >         <tr> >             <td>sender.individual.identity_document.number</td> >             <td>Required (with type INDIVIDUAL)</td> <!-- Nigeria --> >         </tr> >         <tr> >             <td>sender.individual.identity_document.issued_on</td> >             <td>-</td> <!-- Nigeria --> >         </tr> >         <tr> >             <td>sender.individual.identity_document.expires_on</td> >             <td>Required (with type INDIVIDUAL)</td> <!-- Nigeria --> >         </tr> >     </tbody> > </table> > <br> > </details> >  > <details> > <summary>ğŸ‡¹ğŸ‡¿ Tanzania</summary> > <table> >     <thead> >         <tr> >             <th>Field</th> >         </tr> >     </thead> >     <tbody> >         <tr> >             <td>amount.value</td> >             <td> >                 <table> >                     <thead> >                          <tr> >                             <th>Min</th> >                             <th>Max</th> >                         </tr> >                     </thead> >                     <tbody> >                         <tr> >                             <td>2,500 TZS</td> >                             <td>1,000,000 TZS</td> >                         </tr> >                     </tbody> >                 </table> >             </td> <!-- Tanzania --> >         </tr> >         <tr> >             <td>sender.type</td> >             <td>Required</td> <!-- Tanzania --> >         </tr> >         <tr> >             <td>sender.name</td> >             <td>Required</td> <!-- Tanzania --> >         </tr> >         <tr> >             <td>sender.address.line1</td> >             <td>Required</td> <!-- Tanzania --> >         </tr> >         <tr> >             <td>sender.address.line2</td> >             <td>-</td> <!-- Tanzania --> >         </tr> >         <tr> >             <td>sender.address.line3</td> >             <td>-</td> <!-- Tanzania --> >         </tr> >         <tr> >             <td>sender.address.city</td> >             <td>Required</td> <!-- Tanzania --> >         </tr> >         <tr> >             <td>sender.address.postal_code</td> >             <td>Required</td> <!-- Tanzania --> >         </tr> >         <tr> >             <td>sender.address.country</td> >             <td>Required</td> <!-- Tanzania --> >         </tr> >         <tr> >             <td>sender.individual.dob</td> >             <td>Required (with type INDIVIDUAL)</td> <!-- Tanzania --> >         </tr> >         <tr> >             <td>sender.individual.identity_document.country</td> >             <td>Required (with type INDIVIDUAL)</td> <!-- Tanzania --> >         </tr> >         <tr> >             <td>sender.individual.identity_document.number</td> >             <td>Required (with type INDIVIDUAL)</td> <!-- Tanzania --> >         </tr> >         <tr> >             <td>sender.individual.identity_document.issued_on</td> >             <td>-</td> <!-- Tanzania --> >         </tr> >         <tr> >             <td>sender.individual.identity_document.expires_on</td> >             <td>Required (with type INDIVIDUAL)</td> <!-- Tanzania --> >         </tr> >     </tbody> > </table> > <br> > </details> >  > <details> > <summary>ğŸ‡·ğŸ‡¼ Rwanda</summary> > <table> >     <thead> >         <tr> >             <th>Field</th> >         </tr> >     </thead> >     <tbody> >         <tr> >             <td>amount.value</td> >             <td> >                 <table> >                     <thead> >                         <tr> >                             <th>Min</th> >                             <th>Max</th> >                         </tr> >                     </thead> >                     <tbody> >                         <tr> >                             <td>500 RWF</td> >                             <td>-</td> >                         </tr> >                     </tbody> >                 </table> >             </td> <!-- Rwanda --> >         </tr> >         <tr> >             <td>sender.type</td> >             <td>Required</td> <!-- Rwanda --> >         </tr> >         <tr> >             <td>sender.name</td> >             <td>Required</td> <!-- Rwanda --> >         </tr> >         <tr> >             <td>sender.address.line1</td> >             <td>Required</td> <!-- Rwanda --> >         </tr> >         <tr> >             <td>sender.address.line2</td> >             <td>-</td> <!-- Rwanda --> >         </tr> >         <tr> >             <td>sender.address.line3</td> >             <td>-</td> <!-- Rwanda --> >         </tr> >         <tr> >             <td>sender.address.city</td> >             <td>Required</td> <!-- Rwanda --> >         </tr> >         <tr> >             <td>sender.address.postal_code</td> >             <td>Required</td> <!-- Rwanda --> >         </tr> >         <tr> >             <td>sender.address.country</td> >             <td>Required</td> <!-- Rwanda --> >         </tr> >         <tr> >             <td>sender.individual.dob</td> >             <td>Required (with type INDIVIDUAL)</td> <!-- Rwanda --> >         </tr> >         <tr> >             <td>sender.individual.identity_document.country</td> >             <td>Required (with type INDIVIDUAL)</td> <!-- Rwanda --> >         </tr> >         <tr> >             <td>sender.individual.identity_document.number</td> >             <td>Required (with type INDIVIDUAL)</td> <!-- Rwanda --> >         </tr> >         <tr> >             <td>sender.individual.identity_document.issued_on</td> >             <td>-</td> <!-- Rwanda --> >         </tr> >         <tr> >             <td>sender.individual.identity_document.expires_on</td> >             <td>Required (with type INDIVIDUAL)</td> <!-- Rwanda --> >         </tr> >     </tbody> > </table> > <br> > </details>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.payouts_post_with_http_info(x_idempotency_key, openapi_payout_create_request, async_req=True)
        >>> result = thread.get()

        :param x_idempotency_key: ğŸš¨ï¸ Prevent duplicate payouts! See: [x-idempotency-key security scheme](idempotency) (required)
        :type x_idempotency_key: str
        :param openapi_payout_create_request: The payout (required)
        :type openapi_payout_create_request: OpenapiPayoutCreateRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PayoutsPost202Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'x_idempotency_key',
            'openapi_payout_create_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method payouts_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['x_idempotency_key']:
            _header_params['X-Idempotency-Key'] = _params['x_idempotency_key']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['openapi_payout_create_request'] is not None:
            _body_params = _params['openapi_payout_create_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['Bearer']  # noqa: E501

        _response_types_map = {
            '202': "PayoutsPost202Response",
            '402': "OpenapiResponseBodyWalletInsufficientBalance",
            '409': "OpenapiResponseBodyIdempotencyConflict",
            '422': "OpenapiResponseBodyValidationFailed",
            '500': "OpenapiResponseBodyInternalServerError",
        }

        return self.api_client.call_api(
            '/payouts', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
